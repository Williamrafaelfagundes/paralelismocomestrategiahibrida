# paralelismocomestrategiahibrida
 Otimiza√ß√£o de Portf√≥lios de A√ß√µes (H√≠brido CPU/GPU)Este projeto implementa uma solu√ß√£o de otimiza√ß√£o de portf√≥lios utilizando uma arquitetura de programa√ß√£o paralela h√≠brida que combina Python, C, Pthreads (CPU) e CUDA (GPU). O objetivo √© simular milh√µes de combina√ß√µes de pesos de ativos (Portf√≥lios Monte Carlo) para identificar o portf√≥lio que oferece o melhor Sharpe Ratio (retorno ajustado ao risco).üöÄ Arquitetura e TecnologiaO projeto foi estruturado em tr√™s fases principais para maximizar a efici√™ncia e aproveitar os pontos fortes de cada tecnologia:FaseFerramentasTipo de ParalelismoDescri√ß√£o1. Ingest√£o de DadosPython (yfinance, numpy)SequencialObt√©m dados hist√≥ricos de pre√ßos de a√ß√µes e calcula os retornos di√°rios logar√≠tmicos, salvando-os em formato bin√°rio.2. Pr√©-ProcessamentoC/C++ (Pthreads)Paralelismo de CPUL√™ os dados brutos e calcula a Matriz de Covari√¢ncia e os Retornos M√©dios Anualizados, tarefas que s√£o computacionalmente intensivas e ideais para o paralelismo multicore da CPU.3. Otimiza√ß√£oC/C++ (CUDA)Paralelismo de GPUTransfere a Matriz de Covari√¢ncia para a mem√≥ria da GPU e dispara um kernel que, em paralelo massivo, simula milh√µes de portf√≥lios (Monte Carlo) e calcula o Sharpe Ratio para cada um, identificando a solu√ß√£o ideal.üíª Estrutura e Fluxo de Execu√ß√£oO fluxo do projeto √© sequencial, garantindo que o processamento intensivo seja realizado no componente de hardware mais adequado:data_fetch.py (Python): Obt√©m $N$ ativos e gera o arquivo log_returns.bin.main.cu (CPU - Pthreads):L√™ log_returns.bin.Dispara 4 threads (ou mais) para calcular a Matriz de Covari√¢ncia $\mathbf{\Sigma}$ (tamanho $N \times N$) e o vetor de Retornos M√©dios $\mathbf{R}_{avg}$.Transfer√™ncia (CUDA Host): Copia $\mathbf{\Sigma}$ e $\mathbf{R}_{avg}$ da mem√≥ria do Host (CPU) para a mem√≥ria do Device (GPU).monte_carlo_kernel (GPU - CUDA):Dispara $10,000,000$ de threads.Cada thread $k$ gera um vetor de pesos $\mathbf{w}_k$.Calcula a Volatilidade ($\sigma_k = \sqrt{\mathbf{w}_k^T \cdot \mathbf{\Sigma} \cdot \mathbf{w}_k}$) e o Retorno ($\mathbf{R}_k = \mathbf{w}_k^T \cdot \mathbf{R}_{avg}$).Calcula o Sharpe Ratio ($\text{SR}_k = (\mathbf{R}_k - R_f) / \sigma_k$).Usa opera√ß√µes at√¥micas (atomicCAS) para garantir que apenas o melhor Sharpe Ratio e seus pesos correspondentes sejam salvos de forma global.üîë Tecnologias ChaveCUDA: Utilizado para paralelismo massivo (milh√µes de threads) na simula√ß√£o Monte Carlo.Pthreads: Utilizado para paralelismo multicore na CPU para c√°lculos de √Ålgebra Linear (Covari√¢ncia).yfinance & numpy: Usados para coleta de dados e manipula√ß√£o num√©rica em Python.‚öôÔ∏è Como RodarEste projeto requer o CUDA Toolkit da NVIDIA instalado.Instalar depend√™ncias Python:Bashpip3 install yfinance numpy Gerar o arquivo de dados bin√°rio:Bashpython3 data_fetch.py Compilar o c√≥digo C/CUDA:Bashnvcc --expt-relaxed-constexpr main.cu -o portfolio -Xcompiler -pthread -lcurand Executar a otimiza√ß√£o:Bash./portfolio üìä Exemplo de Sa√≠da--- Resultado da Otimizacao --- Portf√≥lio com melhor Sharpe Ratio (SR):  Sharpe Ratio: 0.7779  Retorno Anualizado: 23.15%  Volatilidade Anualizada: 27.19%  Pesos:   - AAPL: 11.36%   - GOOGL: 69.96%   - MSFT: 18.68%   - AMZN: 0.00%   - TSLA: 0.00% Performance: CPU (Covariance): 0.0004 s | GPU (Monte Carlo): 0.0150 s
